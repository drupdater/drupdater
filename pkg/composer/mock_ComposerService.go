// Code generated by mockery v2.53.3. DO NOT EDIT.

package composer

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockComposerService is an autogenerated mock type for the ComposerService type
type MockComposerService struct {
	mock.Mock
}

type MockComposerService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockComposerService) EXPECT() *MockComposerService_Expecter {
	return &MockComposerService_Expecter{mock: &_m.Mock}
}

// Audit provides a mock function with given fields: ctx, dir
func (_m *MockComposerService) Audit(ctx context.Context, dir string) (ComposerAudit, error) {
	ret := _m.Called(ctx, dir)

	if len(ret) == 0 {
		panic("no return value specified for Audit")
	}

	var r0 ComposerAudit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (ComposerAudit, error)); ok {
		return rf(ctx, dir)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) ComposerAudit); ok {
		r0 = rf(ctx, dir)
	} else {
		r0 = ret.Get(0).(ComposerAudit)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_Audit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Audit'
type MockComposerService_Audit_Call struct {
	*mock.Call
}

// Audit is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
func (_e *MockComposerService_Expecter) Audit(ctx interface{}, dir interface{}) *MockComposerService_Audit_Call {
	return &MockComposerService_Audit_Call{Call: _e.mock.On("Audit", ctx, dir)}
}

func (_c *MockComposerService_Audit_Call) Run(run func(ctx context.Context, dir string)) *MockComposerService_Audit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockComposerService_Audit_Call) Return(_a0 ComposerAudit, _a1 error) *MockComposerService_Audit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_Audit_Call) RunAndReturn(run func(context.Context, string) (ComposerAudit, error)) *MockComposerService_Audit_Call {
	_c.Call.Return(run)
	return _c
}

// CheckIfPatchApplies provides a mock function with given fields: ctx, packageName, packageVersion, patchPath
func (_m *MockComposerService) CheckIfPatchApplies(ctx context.Context, packageName string, packageVersion string, patchPath string) (bool, error) {
	ret := _m.Called(ctx, packageName, packageVersion, patchPath)

	if len(ret) == 0 {
		panic("no return value specified for CheckIfPatchApplies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (bool, error)); ok {
		return rf(ctx, packageName, packageVersion, patchPath)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) bool); ok {
		r0 = rf(ctx, packageName, packageVersion, patchPath)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, packageName, packageVersion, patchPath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_CheckIfPatchApplies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckIfPatchApplies'
type MockComposerService_CheckIfPatchApplies_Call struct {
	*mock.Call
}

// CheckIfPatchApplies is a helper method to define mock.On call
//   - ctx context.Context
//   - packageName string
//   - packageVersion string
//   - patchPath string
func (_e *MockComposerService_Expecter) CheckIfPatchApplies(ctx interface{}, packageName interface{}, packageVersion interface{}, patchPath interface{}) *MockComposerService_CheckIfPatchApplies_Call {
	return &MockComposerService_CheckIfPatchApplies_Call{Call: _e.mock.On("CheckIfPatchApplies", ctx, packageName, packageVersion, patchPath)}
}

func (_c *MockComposerService_CheckIfPatchApplies_Call) Run(run func(ctx context.Context, packageName string, packageVersion string, patchPath string)) *MockComposerService_CheckIfPatchApplies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockComposerService_CheckIfPatchApplies_Call) Return(_a0 bool, _a1 error) *MockComposerService_CheckIfPatchApplies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_CheckIfPatchApplies_Call) RunAndReturn(run func(context.Context, string, string, string) (bool, error)) *MockComposerService_CheckIfPatchApplies_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllowPlugins provides a mock function with given fields: ctx, dir
func (_m *MockComposerService) GetAllowPlugins(ctx context.Context, dir string) (map[string]bool, error) {
	ret := _m.Called(ctx, dir)

	if len(ret) == 0 {
		panic("no return value specified for GetAllowPlugins")
	}

	var r0 map[string]bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (map[string]bool, error)); ok {
		return rf(ctx, dir)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) map[string]bool); ok {
		r0 = rf(ctx, dir)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_GetAllowPlugins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllowPlugins'
type MockComposerService_GetAllowPlugins_Call struct {
	*mock.Call
}

// GetAllowPlugins is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
func (_e *MockComposerService_Expecter) GetAllowPlugins(ctx interface{}, dir interface{}) *MockComposerService_GetAllowPlugins_Call {
	return &MockComposerService_GetAllowPlugins_Call{Call: _e.mock.On("GetAllowPlugins", ctx, dir)}
}

func (_c *MockComposerService_GetAllowPlugins_Call) Run(run func(ctx context.Context, dir string)) *MockComposerService_GetAllowPlugins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockComposerService_GetAllowPlugins_Call) Return(_a0 map[string]bool, _a1 error) *MockComposerService_GetAllowPlugins_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_GetAllowPlugins_Call) RunAndReturn(run func(context.Context, string) (map[string]bool, error)) *MockComposerService_GetAllowPlugins_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfig provides a mock function with given fields: ctx, dir, key
func (_m *MockComposerService) GetConfig(ctx context.Context, dir string, key string) (string, error) {
	ret := _m.Called(ctx, dir, key)

	if len(ret) == 0 {
		panic("no return value specified for GetConfig")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return rf(ctx, dir, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(ctx, dir, key)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, dir, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_GetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfig'
type MockComposerService_GetConfig_Call struct {
	*mock.Call
}

// GetConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - key string
func (_e *MockComposerService_Expecter) GetConfig(ctx interface{}, dir interface{}, key interface{}) *MockComposerService_GetConfig_Call {
	return &MockComposerService_GetConfig_Call{Call: _e.mock.On("GetConfig", ctx, dir, key)}
}

func (_c *MockComposerService_GetConfig_Call) Run(run func(ctx context.Context, dir string, key string)) *MockComposerService_GetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockComposerService_GetConfig_Call) Return(_a0 string, _a1 error) *MockComposerService_GetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_GetConfig_Call) RunAndReturn(run func(context.Context, string, string) (string, error)) *MockComposerService_GetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetInstalledPackageVersion provides a mock function with given fields: ctx, dir, packageName
func (_m *MockComposerService) GetInstalledPackageVersion(ctx context.Context, dir string, packageName string) (string, error) {
	ret := _m.Called(ctx, dir, packageName)

	if len(ret) == 0 {
		panic("no return value specified for GetInstalledPackageVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return rf(ctx, dir, packageName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(ctx, dir, packageName)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, dir, packageName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_GetInstalledPackageVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInstalledPackageVersion'
type MockComposerService_GetInstalledPackageVersion_Call struct {
	*mock.Call
}

// GetInstalledPackageVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - packageName string
func (_e *MockComposerService_Expecter) GetInstalledPackageVersion(ctx interface{}, dir interface{}, packageName interface{}) *MockComposerService_GetInstalledPackageVersion_Call {
	return &MockComposerService_GetInstalledPackageVersion_Call{Call: _e.mock.On("GetInstalledPackageVersion", ctx, dir, packageName)}
}

func (_c *MockComposerService_GetInstalledPackageVersion_Call) Run(run func(ctx context.Context, dir string, packageName string)) *MockComposerService_GetInstalledPackageVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockComposerService_GetInstalledPackageVersion_Call) Return(_a0 string, _a1 error) *MockComposerService_GetInstalledPackageVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_GetInstalledPackageVersion_Call) RunAndReturn(run func(context.Context, string, string) (string, error)) *MockComposerService_GetInstalledPackageVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetInstalledPlugins provides a mock function with given fields: ctx, dir
func (_m *MockComposerService) GetInstalledPlugins(ctx context.Context, dir string) (map[string]interface{}, error) {
	ret := _m.Called(ctx, dir)

	if len(ret) == 0 {
		panic("no return value specified for GetInstalledPlugins")
	}

	var r0 map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (map[string]interface{}, error)); ok {
		return rf(ctx, dir)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) map[string]interface{}); ok {
		r0 = rf(ctx, dir)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_GetInstalledPlugins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInstalledPlugins'
type MockComposerService_GetInstalledPlugins_Call struct {
	*mock.Call
}

// GetInstalledPlugins is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
func (_e *MockComposerService_Expecter) GetInstalledPlugins(ctx interface{}, dir interface{}) *MockComposerService_GetInstalledPlugins_Call {
	return &MockComposerService_GetInstalledPlugins_Call{Call: _e.mock.On("GetInstalledPlugins", ctx, dir)}
}

func (_c *MockComposerService_GetInstalledPlugins_Call) Run(run func(ctx context.Context, dir string)) *MockComposerService_GetInstalledPlugins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockComposerService_GetInstalledPlugins_Call) Return(_a0 map[string]interface{}, _a1 error) *MockComposerService_GetInstalledPlugins_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_GetInstalledPlugins_Call) RunAndReturn(run func(context.Context, string) (map[string]interface{}, error)) *MockComposerService_GetInstalledPlugins_Call {
	_c.Call.Return(run)
	return _c
}

// GetLockHash provides a mock function with given fields: dir
func (_m *MockComposerService) GetLockHash(dir string) (string, error) {
	ret := _m.Called(dir)

	if len(ret) == 0 {
		panic("no return value specified for GetLockHash")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(dir)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(dir)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_GetLockHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLockHash'
type MockComposerService_GetLockHash_Call struct {
	*mock.Call
}

// GetLockHash is a helper method to define mock.On call
//   - dir string
func (_e *MockComposerService_Expecter) GetLockHash(dir interface{}) *MockComposerService_GetLockHash_Call {
	return &MockComposerService_GetLockHash_Call{Call: _e.mock.On("GetLockHash", dir)}
}

func (_c *MockComposerService_GetLockHash_Call) Run(run func(dir string)) *MockComposerService_GetLockHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockComposerService_GetLockHash_Call) Return(_a0 string, _a1 error) *MockComposerService_GetLockHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_GetLockHash_Call) RunAndReturn(run func(string) (string, error)) *MockComposerService_GetLockHash_Call {
	_c.Call.Return(run)
	return _c
}

// Install provides a mock function with given fields: ctx, dir
func (_m *MockComposerService) Install(ctx context.Context, dir string) error {
	ret := _m.Called(ctx, dir)

	if len(ret) == 0 {
		panic("no return value specified for Install")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, dir)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockComposerService_Install_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Install'
type MockComposerService_Install_Call struct {
	*mock.Call
}

// Install is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
func (_e *MockComposerService_Expecter) Install(ctx interface{}, dir interface{}) *MockComposerService_Install_Call {
	return &MockComposerService_Install_Call{Call: _e.mock.On("Install", ctx, dir)}
}

func (_c *MockComposerService_Install_Call) Run(run func(ctx context.Context, dir string)) *MockComposerService_Install_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockComposerService_Install_Call) Return(_a0 error) *MockComposerService_Install_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockComposerService_Install_Call) RunAndReturn(run func(context.Context, string) error) *MockComposerService_Install_Call {
	_c.Call.Return(run)
	return _c
}

// IsPackageInstalled provides a mock function with given fields: ctx, dir, packageToCheck
func (_m *MockComposerService) IsPackageInstalled(ctx context.Context, dir string, packageToCheck string) (bool, error) {
	ret := _m.Called(ctx, dir, packageToCheck)

	if len(ret) == 0 {
		panic("no return value specified for IsPackageInstalled")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, dir, packageToCheck)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, dir, packageToCheck)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, dir, packageToCheck)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_IsPackageInstalled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsPackageInstalled'
type MockComposerService_IsPackageInstalled_Call struct {
	*mock.Call
}

// IsPackageInstalled is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - packageToCheck string
func (_e *MockComposerService_Expecter) IsPackageInstalled(ctx interface{}, dir interface{}, packageToCheck interface{}) *MockComposerService_IsPackageInstalled_Call {
	return &MockComposerService_IsPackageInstalled_Call{Call: _e.mock.On("IsPackageInstalled", ctx, dir, packageToCheck)}
}

func (_c *MockComposerService_IsPackageInstalled_Call) Run(run func(ctx context.Context, dir string, packageToCheck string)) *MockComposerService_IsPackageInstalled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockComposerService_IsPackageInstalled_Call) Return(_a0 bool, _a1 error) *MockComposerService_IsPackageInstalled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_IsPackageInstalled_Call) RunAndReturn(run func(context.Context, string, string) (bool, error)) *MockComposerService_IsPackageInstalled_Call {
	_c.Call.Return(run)
	return _c
}

// ListPendingUpdates provides a mock function with given fields: ctx, dir, packagesToUpdate, minimalChanges
func (_m *MockComposerService) ListPendingUpdates(ctx context.Context, dir string, packagesToUpdate []string, minimalChanges bool) ([]PackageChange, error) {
	ret := _m.Called(ctx, dir, packagesToUpdate, minimalChanges)

	if len(ret) == 0 {
		panic("no return value specified for ListPendingUpdates")
	}

	var r0 []PackageChange
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, bool) ([]PackageChange, error)); ok {
		return rf(ctx, dir, packagesToUpdate, minimalChanges)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, bool) []PackageChange); ok {
		r0 = rf(ctx, dir, packagesToUpdate, minimalChanges)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]PackageChange)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, bool) error); ok {
		r1 = rf(ctx, dir, packagesToUpdate, minimalChanges)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_ListPendingUpdates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPendingUpdates'
type MockComposerService_ListPendingUpdates_Call struct {
	*mock.Call
}

// ListPendingUpdates is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - packagesToUpdate []string
//   - minimalChanges bool
func (_e *MockComposerService_Expecter) ListPendingUpdates(ctx interface{}, dir interface{}, packagesToUpdate interface{}, minimalChanges interface{}) *MockComposerService_ListPendingUpdates_Call {
	return &MockComposerService_ListPendingUpdates_Call{Call: _e.mock.On("ListPendingUpdates", ctx, dir, packagesToUpdate, minimalChanges)}
}

func (_c *MockComposerService_ListPendingUpdates_Call) Run(run func(ctx context.Context, dir string, packagesToUpdate []string, minimalChanges bool)) *MockComposerService_ListPendingUpdates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(bool))
	})
	return _c
}

func (_c *MockComposerService_ListPendingUpdates_Call) Return(_a0 []PackageChange, _a1 error) *MockComposerService_ListPendingUpdates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_ListPendingUpdates_Call) RunAndReturn(run func(context.Context, string, []string, bool) ([]PackageChange, error)) *MockComposerService_ListPendingUpdates_Call {
	_c.Call.Return(run)
	return _c
}

// Normalize provides a mock function with given fields: ctx, dir
func (_m *MockComposerService) Normalize(ctx context.Context, dir string) (string, error) {
	ret := _m.Called(ctx, dir)

	if len(ret) == 0 {
		panic("no return value specified for Normalize")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, dir)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, dir)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_Normalize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Normalize'
type MockComposerService_Normalize_Call struct {
	*mock.Call
}

// Normalize is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
func (_e *MockComposerService_Expecter) Normalize(ctx interface{}, dir interface{}) *MockComposerService_Normalize_Call {
	return &MockComposerService_Normalize_Call{Call: _e.mock.On("Normalize", ctx, dir)}
}

func (_c *MockComposerService_Normalize_Call) Run(run func(ctx context.Context, dir string)) *MockComposerService_Normalize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockComposerService_Normalize_Call) Return(_a0 string, _a1 error) *MockComposerService_Normalize_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_Normalize_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockComposerService_Normalize_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function with given fields: ctx, dir, packages
func (_m *MockComposerService) Remove(ctx context.Context, dir string, packages ...string) (string, error) {
	_va := make([]interface{}, len(packages))
	for _i := range packages {
		_va[_i] = packages[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, dir)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) (string, error)); ok {
		return rf(ctx, dir, packages...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) string); ok {
		r0 = rf(ctx, dir, packages...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...string) error); ok {
		r1 = rf(ctx, dir, packages...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type MockComposerService_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - packages ...string
func (_e *MockComposerService_Expecter) Remove(ctx interface{}, dir interface{}, packages ...interface{}) *MockComposerService_Remove_Call {
	return &MockComposerService_Remove_Call{Call: _e.mock.On("Remove",
		append([]interface{}{ctx, dir}, packages...)...)}
}

func (_c *MockComposerService_Remove_Call) Run(run func(ctx context.Context, dir string, packages ...string)) *MockComposerService_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockComposerService_Remove_Call) Return(_a0 string, _a1 error) *MockComposerService_Remove_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_Remove_Call) RunAndReturn(run func(context.Context, string, ...string) (string, error)) *MockComposerService_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Require provides a mock function with given fields: ctx, dir, args
func (_m *MockComposerService) Require(ctx context.Context, dir string, args ...string) (string, error) {
	_va := make([]interface{}, len(args))
	for _i := range args {
		_va[_i] = args[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, dir)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Require")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) (string, error)); ok {
		return rf(ctx, dir, args...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) string); ok {
		r0 = rf(ctx, dir, args...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...string) error); ok {
		r1 = rf(ctx, dir, args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_Require_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Require'
type MockComposerService_Require_Call struct {
	*mock.Call
}

// Require is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - args ...string
func (_e *MockComposerService_Expecter) Require(ctx interface{}, dir interface{}, args ...interface{}) *MockComposerService_Require_Call {
	return &MockComposerService_Require_Call{Call: _e.mock.On("Require",
		append([]interface{}{ctx, dir}, args...)...)}
}

func (_c *MockComposerService_Require_Call) Run(run func(ctx context.Context, dir string, args ...string)) *MockComposerService_Require_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockComposerService_Require_Call) Return(_a0 string, _a1 error) *MockComposerService_Require_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_Require_Call) RunAndReturn(run func(context.Context, string, ...string) (string, error)) *MockComposerService_Require_Call {
	_c.Call.Return(run)
	return _c
}

// SetAllowPlugins provides a mock function with given fields: ctx, dir, plugins
func (_m *MockComposerService) SetAllowPlugins(ctx context.Context, dir string, plugins map[string]bool) error {
	ret := _m.Called(ctx, dir, plugins)

	if len(ret) == 0 {
		panic("no return value specified for SetAllowPlugins")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]bool) error); ok {
		r0 = rf(ctx, dir, plugins)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockComposerService_SetAllowPlugins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetAllowPlugins'
type MockComposerService_SetAllowPlugins_Call struct {
	*mock.Call
}

// SetAllowPlugins is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - plugins map[string]bool
func (_e *MockComposerService_Expecter) SetAllowPlugins(ctx interface{}, dir interface{}, plugins interface{}) *MockComposerService_SetAllowPlugins_Call {
	return &MockComposerService_SetAllowPlugins_Call{Call: _e.mock.On("SetAllowPlugins", ctx, dir, plugins)}
}

func (_c *MockComposerService_SetAllowPlugins_Call) Run(run func(ctx context.Context, dir string, plugins map[string]bool)) *MockComposerService_SetAllowPlugins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]bool))
	})
	return _c
}

func (_c *MockComposerService_SetAllowPlugins_Call) Return(_a0 error) *MockComposerService_SetAllowPlugins_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockComposerService_SetAllowPlugins_Call) RunAndReturn(run func(context.Context, string, map[string]bool) error) *MockComposerService_SetAllowPlugins_Call {
	_c.Call.Return(run)
	return _c
}

// SetConfig provides a mock function with given fields: ctx, dir, key, value
func (_m *MockComposerService) SetConfig(ctx context.Context, dir string, key string, value string) error {
	ret := _m.Called(ctx, dir, key, value)

	if len(ret) == 0 {
		panic("no return value specified for SetConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, dir, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockComposerService_SetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetConfig'
type MockComposerService_SetConfig_Call struct {
	*mock.Call
}

// SetConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - key string
//   - value string
func (_e *MockComposerService_Expecter) SetConfig(ctx interface{}, dir interface{}, key interface{}, value interface{}) *MockComposerService_SetConfig_Call {
	return &MockComposerService_SetConfig_Call{Call: _e.mock.On("SetConfig", ctx, dir, key, value)}
}

func (_c *MockComposerService_SetConfig_Call) Run(run func(ctx context.Context, dir string, key string, value string)) *MockComposerService_SetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockComposerService_SetConfig_Call) Return(_a0 error) *MockComposerService_SetConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockComposerService_SetConfig_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockComposerService_SetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, dir, packagesToUpdate, packagesToKeep, minimalChanges, dryRun
func (_m *MockComposerService) Update(ctx context.Context, dir string, packagesToUpdate []string, packagesToKeep []string, minimalChanges bool, dryRun bool) (string, error) {
	ret := _m.Called(ctx, dir, packagesToUpdate, packagesToKeep, minimalChanges, dryRun)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, []string, bool, bool) (string, error)); ok {
		return rf(ctx, dir, packagesToUpdate, packagesToKeep, minimalChanges, dryRun)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, []string, bool, bool) string); ok {
		r0 = rf(ctx, dir, packagesToUpdate, packagesToKeep, minimalChanges, dryRun)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, []string, bool, bool) error); ok {
		r1 = rf(ctx, dir, packagesToUpdate, packagesToKeep, minimalChanges, dryRun)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComposerService_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockComposerService_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - packagesToUpdate []string
//   - packagesToKeep []string
//   - minimalChanges bool
//   - dryRun bool
func (_e *MockComposerService_Expecter) Update(ctx interface{}, dir interface{}, packagesToUpdate interface{}, packagesToKeep interface{}, minimalChanges interface{}, dryRun interface{}) *MockComposerService_Update_Call {
	return &MockComposerService_Update_Call{Call: _e.mock.On("Update", ctx, dir, packagesToUpdate, packagesToKeep, minimalChanges, dryRun)}
}

func (_c *MockComposerService_Update_Call) Run(run func(ctx context.Context, dir string, packagesToUpdate []string, packagesToKeep []string, minimalChanges bool, dryRun bool)) *MockComposerService_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].([]string), args[4].(bool), args[5].(bool))
	})
	return _c
}

func (_c *MockComposerService_Update_Call) Return(_a0 string, _a1 error) *MockComposerService_Update_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComposerService_Update_Call) RunAndReturn(run func(context.Context, string, []string, []string, bool, bool) (string, error)) *MockComposerService_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockComposerService creates a new instance of MockComposerService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockComposerService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockComposerService {
	mock := &MockComposerService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Code generated by mockery v2.53.3. DO NOT EDIT.

package composer

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockRunner is an autogenerated mock type for the Runner type
type MockRunner struct {
	mock.Mock
}

type MockRunner_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRunner) EXPECT() *MockRunner_Expecter {
	return &MockRunner_Expecter{mock: &_m.Mock}
}

// Audit provides a mock function with given fields: ctx, dir
func (_m *MockRunner) Audit(ctx context.Context, dir string) (Audit, error) {
	ret := _m.Called(ctx, dir)

	if len(ret) == 0 {
		panic("no return value specified for Audit")
	}

	var r0 Audit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (Audit, error)); ok {
		return rf(ctx, dir)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) Audit); ok {
		r0 = rf(ctx, dir)
	} else {
		r0 = ret.Get(0).(Audit)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_Audit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Audit'
type MockRunner_Audit_Call struct {
	*mock.Call
}

// Audit is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
func (_e *MockRunner_Expecter) Audit(ctx interface{}, dir interface{}) *MockRunner_Audit_Call {
	return &MockRunner_Audit_Call{Call: _e.mock.On("Audit", ctx, dir)}
}

func (_c *MockRunner_Audit_Call) Run(run func(ctx context.Context, dir string)) *MockRunner_Audit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRunner_Audit_Call) Return(_a0 Audit, _a1 error) *MockRunner_Audit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_Audit_Call) RunAndReturn(run func(context.Context, string) (Audit, error)) *MockRunner_Audit_Call {
	_c.Call.Return(run)
	return _c
}

// CheckIfPatchApplies provides a mock function with given fields: ctx, packageName, packageVersion, patchPath
func (_m *MockRunner) CheckIfPatchApplies(ctx context.Context, packageName string, packageVersion string, patchPath string) (bool, error) {
	ret := _m.Called(ctx, packageName, packageVersion, patchPath)

	if len(ret) == 0 {
		panic("no return value specified for CheckIfPatchApplies")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (bool, error)); ok {
		return rf(ctx, packageName, packageVersion, patchPath)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) bool); ok {
		r0 = rf(ctx, packageName, packageVersion, patchPath)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, packageName, packageVersion, patchPath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_CheckIfPatchApplies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckIfPatchApplies'
type MockRunner_CheckIfPatchApplies_Call struct {
	*mock.Call
}

// CheckIfPatchApplies is a helper method to define mock.On call
//   - ctx context.Context
//   - packageName string
//   - packageVersion string
//   - patchPath string
func (_e *MockRunner_Expecter) CheckIfPatchApplies(ctx interface{}, packageName interface{}, packageVersion interface{}, patchPath interface{}) *MockRunner_CheckIfPatchApplies_Call {
	return &MockRunner_CheckIfPatchApplies_Call{Call: _e.mock.On("CheckIfPatchApplies", ctx, packageName, packageVersion, patchPath)}
}

func (_c *MockRunner_CheckIfPatchApplies_Call) Run(run func(ctx context.Context, packageName string, packageVersion string, patchPath string)) *MockRunner_CheckIfPatchApplies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockRunner_CheckIfPatchApplies_Call) Return(_a0 bool, _a1 error) *MockRunner_CheckIfPatchApplies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_CheckIfPatchApplies_Call) RunAndReturn(run func(context.Context, string, string, string) (bool, error)) *MockRunner_CheckIfPatchApplies_Call {
	_c.Call.Return(run)
	return _c
}

// Diff provides a mock function with given fields: ctx, path, targetBranch, withLinks
func (_m *MockRunner) Diff(ctx context.Context, path string, targetBranch string, withLinks bool) (string, error) {
	ret := _m.Called(ctx, path, targetBranch, withLinks)

	if len(ret) == 0 {
		panic("no return value specified for Diff")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) (string, error)); ok {
		return rf(ctx, path, targetBranch, withLinks)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok {
		r0 = rf(ctx, path, targetBranch, withLinks)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) error); ok {
		r1 = rf(ctx, path, targetBranch, withLinks)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_Diff_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Diff'
type MockRunner_Diff_Call struct {
	*mock.Call
}

// Diff is a helper method to define mock.On call
//   - ctx context.Context
//   - path string
//   - targetBranch string
//   - withLinks bool
func (_e *MockRunner_Expecter) Diff(ctx interface{}, path interface{}, targetBranch interface{}, withLinks interface{}) *MockRunner_Diff_Call {
	return &MockRunner_Diff_Call{Call: _e.mock.On("Diff", ctx, path, targetBranch, withLinks)}
}

func (_c *MockRunner_Diff_Call) Run(run func(ctx context.Context, path string, targetBranch string, withLinks bool)) *MockRunner_Diff_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockRunner_Diff_Call) Return(_a0 string, _a1 error) *MockRunner_Diff_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_Diff_Call) RunAndReturn(run func(context.Context, string, string, bool) (string, error)) *MockRunner_Diff_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllowPlugins provides a mock function with given fields: ctx, dir
func (_m *MockRunner) GetAllowPlugins(ctx context.Context, dir string) (map[string]bool, error) {
	ret := _m.Called(ctx, dir)

	if len(ret) == 0 {
		panic("no return value specified for GetAllowPlugins")
	}

	var r0 map[string]bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (map[string]bool, error)); ok {
		return rf(ctx, dir)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) map[string]bool); ok {
		r0 = rf(ctx, dir)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]bool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_GetAllowPlugins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllowPlugins'
type MockRunner_GetAllowPlugins_Call struct {
	*mock.Call
}

// GetAllowPlugins is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
func (_e *MockRunner_Expecter) GetAllowPlugins(ctx interface{}, dir interface{}) *MockRunner_GetAllowPlugins_Call {
	return &MockRunner_GetAllowPlugins_Call{Call: _e.mock.On("GetAllowPlugins", ctx, dir)}
}

func (_c *MockRunner_GetAllowPlugins_Call) Run(run func(ctx context.Context, dir string)) *MockRunner_GetAllowPlugins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRunner_GetAllowPlugins_Call) Return(_a0 map[string]bool, _a1 error) *MockRunner_GetAllowPlugins_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_GetAllowPlugins_Call) RunAndReturn(run func(context.Context, string) (map[string]bool, error)) *MockRunner_GetAllowPlugins_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfig provides a mock function with given fields: ctx, dir, key
func (_m *MockRunner) GetConfig(ctx context.Context, dir string, key string) (string, error) {
	ret := _m.Called(ctx, dir, key)

	if len(ret) == 0 {
		panic("no return value specified for GetConfig")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return rf(ctx, dir, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(ctx, dir, key)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, dir, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_GetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfig'
type MockRunner_GetConfig_Call struct {
	*mock.Call
}

// GetConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - key string
func (_e *MockRunner_Expecter) GetConfig(ctx interface{}, dir interface{}, key interface{}) *MockRunner_GetConfig_Call {
	return &MockRunner_GetConfig_Call{Call: _e.mock.On("GetConfig", ctx, dir, key)}
}

func (_c *MockRunner_GetConfig_Call) Run(run func(ctx context.Context, dir string, key string)) *MockRunner_GetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRunner_GetConfig_Call) Return(_a0 string, _a1 error) *MockRunner_GetConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_GetConfig_Call) RunAndReturn(run func(context.Context, string, string) (string, error)) *MockRunner_GetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetCustomCodeDirectories provides a mock function with given fields: ctx, dir
func (_m *MockRunner) GetCustomCodeDirectories(ctx context.Context, dir string) ([]string, error) {
	ret := _m.Called(ctx, dir)

	if len(ret) == 0 {
		panic("no return value specified for GetCustomCodeDirectories")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]string, error)); ok {
		return rf(ctx, dir)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = rf(ctx, dir)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_GetCustomCodeDirectories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCustomCodeDirectories'
type MockRunner_GetCustomCodeDirectories_Call struct {
	*mock.Call
}

// GetCustomCodeDirectories is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
func (_e *MockRunner_Expecter) GetCustomCodeDirectories(ctx interface{}, dir interface{}) *MockRunner_GetCustomCodeDirectories_Call {
	return &MockRunner_GetCustomCodeDirectories_Call{Call: _e.mock.On("GetCustomCodeDirectories", ctx, dir)}
}

func (_c *MockRunner_GetCustomCodeDirectories_Call) Run(run func(ctx context.Context, dir string)) *MockRunner_GetCustomCodeDirectories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRunner_GetCustomCodeDirectories_Call) Return(_a0 []string, _a1 error) *MockRunner_GetCustomCodeDirectories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_GetCustomCodeDirectories_Call) RunAndReturn(run func(context.Context, string) ([]string, error)) *MockRunner_GetCustomCodeDirectories_Call {
	_c.Call.Return(run)
	return _c
}

// GetInstalledPackageVersion provides a mock function with given fields: ctx, dir, packageName
func (_m *MockRunner) GetInstalledPackageVersion(ctx context.Context, dir string, packageName string) (string, error) {
	ret := _m.Called(ctx, dir, packageName)

	if len(ret) == 0 {
		panic("no return value specified for GetInstalledPackageVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return rf(ctx, dir, packageName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(ctx, dir, packageName)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, dir, packageName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_GetInstalledPackageVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInstalledPackageVersion'
type MockRunner_GetInstalledPackageVersion_Call struct {
	*mock.Call
}

// GetInstalledPackageVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - packageName string
func (_e *MockRunner_Expecter) GetInstalledPackageVersion(ctx interface{}, dir interface{}, packageName interface{}) *MockRunner_GetInstalledPackageVersion_Call {
	return &MockRunner_GetInstalledPackageVersion_Call{Call: _e.mock.On("GetInstalledPackageVersion", ctx, dir, packageName)}
}

func (_c *MockRunner_GetInstalledPackageVersion_Call) Run(run func(ctx context.Context, dir string, packageName string)) *MockRunner_GetInstalledPackageVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRunner_GetInstalledPackageVersion_Call) Return(_a0 string, _a1 error) *MockRunner_GetInstalledPackageVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_GetInstalledPackageVersion_Call) RunAndReturn(run func(context.Context, string, string) (string, error)) *MockRunner_GetInstalledPackageVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetInstalledPlugins provides a mock function with given fields: ctx, dir
func (_m *MockRunner) GetInstalledPlugins(ctx context.Context, dir string) (map[string]interface{}, error) {
	ret := _m.Called(ctx, dir)

	if len(ret) == 0 {
		panic("no return value specified for GetInstalledPlugins")
	}

	var r0 map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (map[string]interface{}, error)); ok {
		return rf(ctx, dir)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) map[string]interface{}); ok {
		r0 = rf(ctx, dir)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_GetInstalledPlugins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInstalledPlugins'
type MockRunner_GetInstalledPlugins_Call struct {
	*mock.Call
}

// GetInstalledPlugins is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
func (_e *MockRunner_Expecter) GetInstalledPlugins(ctx interface{}, dir interface{}) *MockRunner_GetInstalledPlugins_Call {
	return &MockRunner_GetInstalledPlugins_Call{Call: _e.mock.On("GetInstalledPlugins", ctx, dir)}
}

func (_c *MockRunner_GetInstalledPlugins_Call) Run(run func(ctx context.Context, dir string)) *MockRunner_GetInstalledPlugins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRunner_GetInstalledPlugins_Call) Return(_a0 map[string]interface{}, _a1 error) *MockRunner_GetInstalledPlugins_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_GetInstalledPlugins_Call) RunAndReturn(run func(context.Context, string) (map[string]interface{}, error)) *MockRunner_GetInstalledPlugins_Call {
	_c.Call.Return(run)
	return _c
}

// GetLockHash provides a mock function with given fields: dir
func (_m *MockRunner) GetLockHash(dir string) (string, error) {
	ret := _m.Called(dir)

	if len(ret) == 0 {
		panic("no return value specified for GetLockHash")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(dir)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(dir)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_GetLockHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLockHash'
type MockRunner_GetLockHash_Call struct {
	*mock.Call
}

// GetLockHash is a helper method to define mock.On call
//   - dir string
func (_e *MockRunner_Expecter) GetLockHash(dir interface{}) *MockRunner_GetLockHash_Call {
	return &MockRunner_GetLockHash_Call{Call: _e.mock.On("GetLockHash", dir)}
}

func (_c *MockRunner_GetLockHash_Call) Run(run func(dir string)) *MockRunner_GetLockHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockRunner_GetLockHash_Call) Return(_a0 string, _a1 error) *MockRunner_GetLockHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_GetLockHash_Call) RunAndReturn(run func(string) (string, error)) *MockRunner_GetLockHash_Call {
	_c.Call.Return(run)
	return _c
}

// Install provides a mock function with given fields: ctx, dir
func (_m *MockRunner) Install(ctx context.Context, dir string) error {
	ret := _m.Called(ctx, dir)

	if len(ret) == 0 {
		panic("no return value specified for Install")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, dir)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRunner_Install_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Install'
type MockRunner_Install_Call struct {
	*mock.Call
}

// Install is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
func (_e *MockRunner_Expecter) Install(ctx interface{}, dir interface{}) *MockRunner_Install_Call {
	return &MockRunner_Install_Call{Call: _e.mock.On("Install", ctx, dir)}
}

func (_c *MockRunner_Install_Call) Run(run func(ctx context.Context, dir string)) *MockRunner_Install_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRunner_Install_Call) Return(_a0 error) *MockRunner_Install_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRunner_Install_Call) RunAndReturn(run func(context.Context, string) error) *MockRunner_Install_Call {
	_c.Call.Return(run)
	return _c
}

// IsPackageInstalled provides a mock function with given fields: ctx, dir, packageToCheck
func (_m *MockRunner) IsPackageInstalled(ctx context.Context, dir string, packageToCheck string) (bool, error) {
	ret := _m.Called(ctx, dir, packageToCheck)

	if len(ret) == 0 {
		panic("no return value specified for IsPackageInstalled")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return rf(ctx, dir, packageToCheck)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, dir, packageToCheck)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, dir, packageToCheck)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_IsPackageInstalled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsPackageInstalled'
type MockRunner_IsPackageInstalled_Call struct {
	*mock.Call
}

// IsPackageInstalled is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - packageToCheck string
func (_e *MockRunner_Expecter) IsPackageInstalled(ctx interface{}, dir interface{}, packageToCheck interface{}) *MockRunner_IsPackageInstalled_Call {
	return &MockRunner_IsPackageInstalled_Call{Call: _e.mock.On("IsPackageInstalled", ctx, dir, packageToCheck)}
}

func (_c *MockRunner_IsPackageInstalled_Call) Run(run func(ctx context.Context, dir string, packageToCheck string)) *MockRunner_IsPackageInstalled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRunner_IsPackageInstalled_Call) Return(_a0 bool, _a1 error) *MockRunner_IsPackageInstalled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_IsPackageInstalled_Call) RunAndReturn(run func(context.Context, string, string) (bool, error)) *MockRunner_IsPackageInstalled_Call {
	_c.Call.Return(run)
	return _c
}

// ListPendingUpdates provides a mock function with given fields: ctx, dir, packagesToUpdate, minimalChanges
func (_m *MockRunner) ListPendingUpdates(ctx context.Context, dir string, packagesToUpdate []string, minimalChanges bool) ([]PackageChange, error) {
	ret := _m.Called(ctx, dir, packagesToUpdate, minimalChanges)

	if len(ret) == 0 {
		panic("no return value specified for ListPendingUpdates")
	}

	var r0 []PackageChange
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, bool) ([]PackageChange, error)); ok {
		return rf(ctx, dir, packagesToUpdate, minimalChanges)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, bool) []PackageChange); ok {
		r0 = rf(ctx, dir, packagesToUpdate, minimalChanges)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]PackageChange)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, bool) error); ok {
		r1 = rf(ctx, dir, packagesToUpdate, minimalChanges)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_ListPendingUpdates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPendingUpdates'
type MockRunner_ListPendingUpdates_Call struct {
	*mock.Call
}

// ListPendingUpdates is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - packagesToUpdate []string
//   - minimalChanges bool
func (_e *MockRunner_Expecter) ListPendingUpdates(ctx interface{}, dir interface{}, packagesToUpdate interface{}, minimalChanges interface{}) *MockRunner_ListPendingUpdates_Call {
	return &MockRunner_ListPendingUpdates_Call{Call: _e.mock.On("ListPendingUpdates", ctx, dir, packagesToUpdate, minimalChanges)}
}

func (_c *MockRunner_ListPendingUpdates_Call) Run(run func(ctx context.Context, dir string, packagesToUpdate []string, minimalChanges bool)) *MockRunner_ListPendingUpdates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(bool))
	})
	return _c
}

func (_c *MockRunner_ListPendingUpdates_Call) Return(_a0 []PackageChange, _a1 error) *MockRunner_ListPendingUpdates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_ListPendingUpdates_Call) RunAndReturn(run func(context.Context, string, []string, bool) ([]PackageChange, error)) *MockRunner_ListPendingUpdates_Call {
	_c.Call.Return(run)
	return _c
}

// Normalize provides a mock function with given fields: ctx, dir
func (_m *MockRunner) Normalize(ctx context.Context, dir string) (string, error) {
	ret := _m.Called(ctx, dir)

	if len(ret) == 0 {
		panic("no return value specified for Normalize")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, dir)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, dir)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dir)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_Normalize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Normalize'
type MockRunner_Normalize_Call struct {
	*mock.Call
}

// Normalize is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
func (_e *MockRunner_Expecter) Normalize(ctx interface{}, dir interface{}) *MockRunner_Normalize_Call {
	return &MockRunner_Normalize_Call{Call: _e.mock.On("Normalize", ctx, dir)}
}

func (_c *MockRunner_Normalize_Call) Run(run func(ctx context.Context, dir string)) *MockRunner_Normalize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRunner_Normalize_Call) Return(_a0 string, _a1 error) *MockRunner_Normalize_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_Normalize_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockRunner_Normalize_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function with given fields: ctx, dir, packages
func (_m *MockRunner) Remove(ctx context.Context, dir string, packages ...string) (string, error) {
	_va := make([]interface{}, len(packages))
	for _i := range packages {
		_va[_i] = packages[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, dir)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) (string, error)); ok {
		return rf(ctx, dir, packages...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) string); ok {
		r0 = rf(ctx, dir, packages...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...string) error); ok {
		r1 = rf(ctx, dir, packages...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type MockRunner_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - packages ...string
func (_e *MockRunner_Expecter) Remove(ctx interface{}, dir interface{}, packages ...interface{}) *MockRunner_Remove_Call {
	return &MockRunner_Remove_Call{Call: _e.mock.On("Remove",
		append([]interface{}{ctx, dir}, packages...)...)}
}

func (_c *MockRunner_Remove_Call) Run(run func(ctx context.Context, dir string, packages ...string)) *MockRunner_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockRunner_Remove_Call) Return(_a0 string, _a1 error) *MockRunner_Remove_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_Remove_Call) RunAndReturn(run func(context.Context, string, ...string) (string, error)) *MockRunner_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// Require provides a mock function with given fields: ctx, dir, args
func (_m *MockRunner) Require(ctx context.Context, dir string, args ...string) (string, error) {
	_va := make([]interface{}, len(args))
	for _i := range args {
		_va[_i] = args[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, dir)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Require")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) (string, error)); ok {
		return rf(ctx, dir, args...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) string); ok {
		r0 = rf(ctx, dir, args...)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...string) error); ok {
		r1 = rf(ctx, dir, args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_Require_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Require'
type MockRunner_Require_Call struct {
	*mock.Call
}

// Require is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - args ...string
func (_e *MockRunner_Expecter) Require(ctx interface{}, dir interface{}, args ...interface{}) *MockRunner_Require_Call {
	return &MockRunner_Require_Call{Call: _e.mock.On("Require",
		append([]interface{}{ctx, dir}, args...)...)}
}

func (_c *MockRunner_Require_Call) Run(run func(ctx context.Context, dir string, args ...string)) *MockRunner_Require_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockRunner_Require_Call) Return(_a0 string, _a1 error) *MockRunner_Require_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_Require_Call) RunAndReturn(run func(context.Context, string, ...string) (string, error)) *MockRunner_Require_Call {
	_c.Call.Return(run)
	return _c
}

// SetAllowPlugins provides a mock function with given fields: ctx, dir, plugins
func (_m *MockRunner) SetAllowPlugins(ctx context.Context, dir string, plugins map[string]bool) error {
	ret := _m.Called(ctx, dir, plugins)

	if len(ret) == 0 {
		panic("no return value specified for SetAllowPlugins")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]bool) error); ok {
		r0 = rf(ctx, dir, plugins)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRunner_SetAllowPlugins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetAllowPlugins'
type MockRunner_SetAllowPlugins_Call struct {
	*mock.Call
}

// SetAllowPlugins is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - plugins map[string]bool
func (_e *MockRunner_Expecter) SetAllowPlugins(ctx interface{}, dir interface{}, plugins interface{}) *MockRunner_SetAllowPlugins_Call {
	return &MockRunner_SetAllowPlugins_Call{Call: _e.mock.On("SetAllowPlugins", ctx, dir, plugins)}
}

func (_c *MockRunner_SetAllowPlugins_Call) Run(run func(ctx context.Context, dir string, plugins map[string]bool)) *MockRunner_SetAllowPlugins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]bool))
	})
	return _c
}

func (_c *MockRunner_SetAllowPlugins_Call) Return(_a0 error) *MockRunner_SetAllowPlugins_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRunner_SetAllowPlugins_Call) RunAndReturn(run func(context.Context, string, map[string]bool) error) *MockRunner_SetAllowPlugins_Call {
	_c.Call.Return(run)
	return _c
}

// SetConfig provides a mock function with given fields: ctx, dir, key, value
func (_m *MockRunner) SetConfig(ctx context.Context, dir string, key string, value string) error {
	ret := _m.Called(ctx, dir, key, value)

	if len(ret) == 0 {
		panic("no return value specified for SetConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, dir, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRunner_SetConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetConfig'
type MockRunner_SetConfig_Call struct {
	*mock.Call
}

// SetConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - key string
//   - value string
func (_e *MockRunner_Expecter) SetConfig(ctx interface{}, dir interface{}, key interface{}, value interface{}) *MockRunner_SetConfig_Call {
	return &MockRunner_SetConfig_Call{Call: _e.mock.On("SetConfig", ctx, dir, key, value)}
}

func (_c *MockRunner_SetConfig_Call) Run(run func(ctx context.Context, dir string, key string, value string)) *MockRunner_SetConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockRunner_SetConfig_Call) Return(_a0 error) *MockRunner_SetConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRunner_SetConfig_Call) RunAndReturn(run func(context.Context, string, string, string) error) *MockRunner_SetConfig_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, dir, packagesToUpdate, packagesToKeep, minimalChanges, dryRun
func (_m *MockRunner) Update(ctx context.Context, dir string, packagesToUpdate []string, packagesToKeep []string, minimalChanges bool, dryRun bool) (string, error) {
	ret := _m.Called(ctx, dir, packagesToUpdate, packagesToKeep, minimalChanges, dryRun)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, []string, bool, bool) (string, error)); ok {
		return rf(ctx, dir, packagesToUpdate, packagesToKeep, minimalChanges, dryRun)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, []string, bool, bool) string); ok {
		r0 = rf(ctx, dir, packagesToUpdate, packagesToKeep, minimalChanges, dryRun)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, []string, bool, bool) error); ok {
		r1 = rf(ctx, dir, packagesToUpdate, packagesToKeep, minimalChanges, dryRun)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRunner_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockRunner_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
//   - packagesToUpdate []string
//   - packagesToKeep []string
//   - minimalChanges bool
//   - dryRun bool
func (_e *MockRunner_Expecter) Update(ctx interface{}, dir interface{}, packagesToUpdate interface{}, packagesToKeep interface{}, minimalChanges interface{}, dryRun interface{}) *MockRunner_Update_Call {
	return &MockRunner_Update_Call{Call: _e.mock.On("Update", ctx, dir, packagesToUpdate, packagesToKeep, minimalChanges, dryRun)}
}

func (_c *MockRunner_Update_Call) Run(run func(ctx context.Context, dir string, packagesToUpdate []string, packagesToKeep []string, minimalChanges bool, dryRun bool)) *MockRunner_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].([]string), args[4].(bool), args[5].(bool))
	})
	return _c
}

func (_c *MockRunner_Update_Call) Return(_a0 string, _a1 error) *MockRunner_Update_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRunner_Update_Call) RunAndReturn(run func(context.Context, string, []string, []string, bool, bool) (string, error)) *MockRunner_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateLockHash provides a mock function with given fields: ctx, dir
func (_m *MockRunner) UpdateLockHash(ctx context.Context, dir string) error {
	ret := _m.Called(ctx, dir)

	if len(ret) == 0 {
		panic("no return value specified for UpdateLockHash")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, dir)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRunner_UpdateLockHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateLockHash'
type MockRunner_UpdateLockHash_Call struct {
	*mock.Call
}

// UpdateLockHash is a helper method to define mock.On call
//   - ctx context.Context
//   - dir string
func (_e *MockRunner_Expecter) UpdateLockHash(ctx interface{}, dir interface{}) *MockRunner_UpdateLockHash_Call {
	return &MockRunner_UpdateLockHash_Call{Call: _e.mock.On("UpdateLockHash", ctx, dir)}
}

func (_c *MockRunner_UpdateLockHash_Call) Run(run func(ctx context.Context, dir string)) *MockRunner_UpdateLockHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRunner_UpdateLockHash_Call) Return(_a0 error) *MockRunner_UpdateLockHash_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRunner_UpdateLockHash_Call) RunAndReturn(run func(context.Context, string) error) *MockRunner_UpdateLockHash_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRunner creates a new instance of MockRunner. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRunner(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRunner {
	mock := &MockRunner{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
